# MySQL 실행계획 분석

### 학습자료 : 업무에 바로 쓰는 SQL 튜닝, 양바른 저

- 쿼리의 실행계획을 보기 위한 명령어 키워드
  - EXPALIN 쿼리;
  - DESCRIBE 쿼리;
  - DESC 쿼리;

## 실행계획 조회시 의미하는 정보들

### 1. id
- 실행 순서를 표시하는 숫자(순서가 낮을 수록 먼저 실행되었음을 의미)
- 조인 또는 서브쿼리를 사용하였을 때, 순서를 확인할 수 있음
- 조인되었다면, 같은 순서로 표시함

### 2. select_type
- select 쿼리의 유형을 표시함

#### SIMPLE
- union 또는 내부 쿼리가 없는 경우를 표시함
- 단순 select 쿼리

#### PRIMARY
- 서브쿼리를 감싸는 외부쿼리
- union이 포함된 쿼리에서 첫 번째로 select를 사용한 쿼리

#### SUBQUERY
- 독립적으로 수행된 서브쿼리를 표시
- select 절의 스칼라 서브쿼리와 where절의 중첩 서브쿼리

#### DERIVED
- from 절에 작성된 서브쿼리를 의미
- 별도의 임시 테이블인 인라인 뷰

#### UNION
- UNION 또는 UNION ALL 구문으로 합쳐진 select 문에서 첫번째 select 이외의 select문


#### UNION RESULT
- UNION ALL이 아닌 UNION 구문으로 SELECT 절을 결합했을 때, 표시함
- UNION의 경우, 임시 테이블을 생성하여 메모리에서 정렬하여 중복체크하는 과정을 거침
- UNION RESULT는 이러한 과정을 진행했다는 것으로 해석할 수 있음
- 데이터의 유일성을 보장할 수 있다면, UNION ALL로 쿼리를 튜닝하는 편이 성능적으로 유리함

#### DEPENDENT SUBQUERY
- UNION 또는 UNION ALL을 사용하는 서브쿼리가 메인 테이블의 영향을 받는 경우에, UNION으로 연결된 쿼리 중에 첫 번째 단위 쿼리를 의미함
- 단위 쿼리가 메인 테이블로부터 값을 하나씩 공급 받아야하는 구조이기에, 쿼리 튜닝 대상이 됨

#### DEPENDENT UNION
- DEPENDENT SUBQUERY와 같이 첫 번째 단위쿼리가 아닌 두 번째 단위쿼리를 의미함
- 쿼리 튜닝 대상

#### UNCACHEABLE SUBQUERY
- 메모리에서 캐싱되어 재활용되어야 할 서브쿼리가 재사용되지 못함을 의미함
- 서브쿼리 내부에 사용자 정의함수나 사용자 변수가 포함된 경우
- RAND(), UUID() 함수 등을 통해서 매번 조회시마다 결과가 달라지는 경우
- 서브쿼리의 결과가 메모리에 상주할 수 있도록, 튜닝을 고려해보는 것이 좋음

#### MATERIALIZED
- IN 절 구문에 연결된 서브쿼리가 임시 테이블을 생성한 뒤, 조인이나 가공작업을 수행할 때 표시함


### 3. table
- 테이블명을 표시하는 항목
- 테이블명 혹은 테이블 별칭(alias)
- 서브쿼리나 임시테이블 생성의 경우
- <subquery#>, <derived#> 으로 표시함(#의 경우 id를 표시)


### 4. partitions
- 데이터가 저장된 논리적인 영역을 표시하는 항목
- 파티션이 나눠져있다면, 특정 파티션에서만 데이터를 조회하는 것이 성능적으로 유리함

### 5. type
- 테이블의 데이터를 어떻게 찾을지에 관한 정보를 제공하는 항목

#### system
- 테이블에 데이터가 없거나, 하나만 있는 경우
- 최고의 성능

#### const
- 조회되는 데이터가 단 1건 출력되는 유형
- 고유 인덱스 또는 기본 키를 사용하여 1건만 조회

#### eq_ref
- 조인이 수행될 때, 드리븐 테이블의 데이터에 접근할 때, 고유 인덱스 또는 기본키로 1건의 데이터만 조회하는 유형
- 조인이 수행될 때, 성능상 가장 좋음

#### ref
- eq_ref와 흡사하지만, 드리븐 테이블의 데이터 접근 범위가 2개 이상인 경우를 의미함
- 드리븐 테이블의 데이터가 많을 경우, 성능 저하의 원인이 되는지 파악할 필요가 있음
- `=`, `>`, `<` 등의 연산자를 사용해서 인덱스로 생성된 열을 비교하는 경우 또한 의미함

#### ref_or_null
- ref 유형과 흡사하지만 IS NULL 구문에 대해서 인덱스를 활용화도록 최적화된 방식
- NULL에 대해서도 인덱스를 활용할 수 있음, 이 때 NULL이 가장 앞쪽에 정렬되어 있음
- NULL 데이터 양이 적다면, 효율적인 쿼리지만, NULL이 많다면 튜닝 대상이 될 수 있음

#### range
- 테이블 내의 연속된 데이터 범위를 조회하는 유형
- `=`, `<>`, `>`, `>=`, `<` , `<=` , IS NULL, `<=>`, BETWEEN, IN 연산을 활용하는 경우
- 범위가 넓으면 성능 저하의 원인이 될 수 있음

#### fulltext
- 텍스트 검색을 위해서 full text index를 활용하는 유형

#### index_merge
- 특정 테이블에 생성된 2개 이상의 인덱스가 병합되어 동시에 적용되는 경우
- full text index는 제외

#### index
- index를 전체 탐색하는 경우(full scan)
- 인덱스 또한 물리적인 영역으로 저장되어 있지만, table 보다는 크기가 작기 때문에 table full scan보다는 유리함

#### ALL
- table full scan
- 인덱스가 없거나, 옵티마이저가 인덱스를 활용하는 것이 더 비효율적이라고 판단했을 경우에 해당함 
- 전체 테이블의 10~20% 이상의 데이터를 조회할 경우 full scan이 성능상 유리할 수 있음 

